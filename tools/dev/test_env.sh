#!/usr/bin/env bash
set -euo pipefail

# Telar Monorepo - Test Environment Orchestrator
# Manages local PostgreSQL and MailHog containers, and materialises test env vars.

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
API_DIR="${REPO_ROOT}/apps/api"

PG_CONT=telar-postgres
PG_PORT=5432
PG_IMAGE=${PG_IMAGE:-postgres:15}
PG_USER=${PG_USER:-postgres}
PG_PASS=${PG_PASS:-postgres}
PG_DB=${PG_DB:-telar_social_test}
PG_SCHEMA=${PG_SCHEMA:-public}
PG_HOST=127.0.0.1

MAILHOG_CONT=telar-mailhog
MAILHOG_SMTP_PORT=1025
MAILHOG_HTTP_PORT=8025
MAILHOG_IMAGE=${MAILHOG_IMAGE:-mailhog/mailhog:latest}
MAILHOG_HOST=127.0.0.1

print_usage() {
  cat <<EOF
Usage: $0 <command> [target]

Commands:
  up [postgres|mailhog|all]     Start containers (default: postgres)
  down [postgres|mailhog|all]   Stop containers
  env                           Print PostgreSQL env exports
  status                        Show container status
  logs [postgres|mailhog]       Tail logs for a container

Environment overrides:
  PG_IMAGE, PG_USER, PG_PASS, PG_DB, PG_SCHEMA
EOF
}

ensure_docker() {
  if ! command -v docker >/dev/null 2>&1; then
    echo "[ERROR] Docker not found. Please install Docker Desktop and retry." >&2
    exit 1
  fi
}

wait_for_port() {
  local host="$1" port="$2" timeout="${3:-30}"
  local start_ts now
  start_ts=$(date +%s)
  echo -n "Waiting for ${host}:${port} "
  while true; do
    if nc -z "${host}" "${port}" >/dev/null 2>&1; then
      echo "[ready]"; return 0
    fi
    now=$(date +%s)
    if (( now - start_ts > timeout )); then
      echo "[timeout]"; return 1
    fi
    sleep 1; echo -n "."
  done
}

start_postgres() {
  if docker ps -a --format '{{.Names}}' | grep -q "^${PG_CONT}$"; then
    echo "[Postgres] Container exists: ${PG_CONT}"
    docker start "${PG_CONT}" >/dev/null || true
  else
    echo "[Postgres] Starting ${PG_IMAGE} on port ${PG_PORT}"
    docker run -d --name "${PG_CONT}" \
      -e POSTGRES_PASSWORD="${PG_PASS}" \
      -e POSTGRES_USER="${PG_USER}" \
      -e POSTGRES_DB="${PG_DB}" \
      -p "${PG_PORT}:5432" "${PG_IMAGE}" >/dev/null
  fi
  echo -n "Waiting for Postgres readiness "
  for _ in {1..40}; do
    if docker exec "${PG_CONT}" pg_isready -U "${PG_USER}" >/dev/null 2>&1; then
      echo "[ready]"; return 0
    fi
    sleep 1; echo -n "."
  done
  echo "[timeout]"; exit 1
}

stop_postgres() {
  docker rm -f "${PG_CONT}" >/dev/null 2>&1 || true
}

start_mailhog() {
  if docker ps -a --format '{{.Names}}' | grep -q "^${MAILHOG_CONT}$"; then
    echo "[MailHog] Container exists: ${MAILHOG_CONT}"
    docker start "${MAILHOG_CONT}" >/dev/null || true
  else
    echo "[MailHog] Starting ${MAILHOG_IMAGE} (SMTP:${MAILHOG_SMTP_PORT}, UI:${MAILHOG_HTTP_PORT})"
    docker run -d --name "${MAILHOG_CONT}" \
      -p "${MAILHOG_SMTP_PORT}:1025" \
      -p "${MAILHOG_HTTP_PORT}:8025" "${MAILHOG_IMAGE}" >/dev/null
  fi
  wait_for_port "${MAILHOG_HOST}" "${MAILHOG_SMTP_PORT}" 20 || {
    echo "[MailHog] Failed to become ready"; exit 1; }
  echo "[MailHog] UI: http://127.0.0.1:${MAILHOG_HTTP_PORT}"
}

stop_mailhog() {
  docker rm -f "${MAILHOG_CONT}" >/dev/null 2>&1 || true
}

print_env_postgres() {
  cat <<EOF
# Generated by test_env.sh
RUN_DB_TESTS="1"
DB_TYPE="postgresql"
POSTGRES_DSN="postgres://${PG_USER}:${PG_PASS}@${PG_HOST}:${PG_PORT}/${PG_DB}?sslmode=disable&search_path=${PG_SCHEMA}"
EOF
}

print_env_smtp() {
  cat <<EOF
# Local SMTP (MailHog)
SMTP_HOST="${MAILHOG_HOST}"
SMTP_PORT="${MAILHOG_SMTP_PORT}"
SMTP_USER=""
SMTP_PASS=""
SMTP_EMAIL="test@example.com"
EOF
}

gen_env_file() {
  local env_file="${API_DIR}/.env"
  local example_file="${API_DIR}/.env.example"
  local temp_file="${env_file}.tmp"

  if [[ ! -f "${env_file}" ]]; then
    echo "[INFO] .env file not found. Creating from ${example_file}."
    if [[ -f "${example_file}" ]]; then
      cp "${example_file}" "${env_file}"
    else
      touch "${env_file}"
    fi
  fi

  grep -v -E "^(RUN_DB_TESTS|POSTGRES_DSN|DB_TYPE|SMTP_HOST|SMTP_PORT|SMTP_USER|SMTP_PASS|SMTP_EMAIL)=" "${env_file}" > "${temp_file}"

  print_env_postgres >>"${temp_file}"
  print_env_smtp >>"${temp_file}"

  mv "${temp_file}" "${env_file}"
  echo "[INFO] Updated database and SMTP configuration in ${env_file}"
}

cmd_up() {
  local target="${1:-postgres}"
  ensure_docker
  case "${target}" in
    postgres) start_postgres; start_mailhog; gen_env_file ;;
    mailhog) start_mailhog ;;
    all) start_postgres; start_mailhog; gen_env_file ;;
    *) echo "Unknown target: ${target}"; exit 1 ;;
  esac
}

cmd_down() {
  local target="${1:-all}"
  ensure_docker
  case "${target}" in
    postgres) stop_postgres ;;
    mailhog) stop_mailhog ;;
    all) stop_postgres; stop_mailhog ;;
    *) echo "Unknown target: ${target}"; exit 1 ;;
  esac
}

cmd_status() {
  ensure_docker
  docker ps -a --filter "name=${PG_CONT}|${MAILHOG_CONT}" --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}' || true
}

cmd_logs() {
  ensure_docker
  local target="${1:-}"
  case "${target}" in
    postgres) docker logs -f "${PG_CONT}" ;;
    mailhog) docker logs -f "${MAILHOG_CONT}" ;;
    *) echo "Specify target: postgres|mailhog"; exit 1 ;;
  esac
}

main() {
  local cmd="${1:-}"; shift || true
  case "${cmd}" in
    up) cmd_up "$@" ;;
    down) cmd_down "$@" ;;
    env) print_env_postgres ;;
    status) cmd_status ;;
    logs) cmd_logs "$@" ;;
    "") print_usage ;;
    *) print_usage; exit 1 ;;
  esac
}

main "$@"

